<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"><title>PJ @ JUDCon 2014 Brazil</title><link href="http://paulojeronimo.github.io/JUDCon-2014-Brazil/css/bootstrap.min.css" rel="stylesheet"><link href="http://paulojeronimo.github.io/JUDCon-2014-Brazil/css/JUDCon-2014-Brazil.css" rel="stylesheet"></head><body><div class="navbar navbar-default navbar-fixed-top" role="navigation"><div class="container"><div class="navbar-header"><button class="navbar-toggle collapsed" data-target=".navbar-collapse" data-toggle="collapse" type="button"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="index.html">PJ @ JUDCon 2014 Brazil</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href="/JUDCon-2014-Brazil/tutorial.html">Tutorial</a></li><li><a href="/JUDCon-2014-Brazil/about.html">About</a></li><li><a href="/JUDCon-2014-Brazil/acknowledgments.html">Acknowledgments</a></li></ul></div></div></div><div class="container"><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Neste tutorial eu explico fundamentos e conceitos para a execução do <a href="https://www.docker.com/">Docker</a> no <a href="https://fedoraproject.org/">Fedora 20</a>. Passos similares ao que apresento aqui também podem ser seguidos no <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/">RHEL 7</a>. Então, eu exploro um caso: a instalação e a configuração do <a href="http://wildfly.org/">WildFly</a> e do <a href="http://wildfly.org/">RHQ</a> nesse ambiente.</p>
</div>
<div class="paragraph">
<p>Desenvolvi esse trabalho para apresentá-lo, inicialmente, na <a href="http://www.jboss.org/events/JUDCon/2014/brazil/speakers.html#wildfly">minha palestra no JUDCon 2014 Brazil</a>. Contudo, mesmo após esse evento, meu tutorial continua em evolução.</p>
</div>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#background-teórico-sobre-o-docker">1. Background teórico sobre o Docker</a>
<ul class="sectlevel2">
<li><a href="#o-que-é-o-docker">1.1. O que é o Docker?</a>
<ul class="sectlevel3">
<li><a href="#porque-os-desenvolvedores-gostam-dele">1.1.1. Porque os desenvolvedores gostam dele?</a></li>
<li><a href="#porque-os-sysadmins-gostam-dele">1.1.2. Porque os sysadmins gostam dele?</a></li>
<li><a href="#arquitetura">1.1.3. Arquitetura</a></li>
<li><a href="#componentes-internos">1.1.4. Componentes internos</a></li>
<li><a href="#como-o-docker-funciona">1.1.5. Como o Docker funciona?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#instalando-o-docker-no-fedora">2. Instalando o Docker no Fedora</a>
<ul class="sectlevel2">
<li><a href="#baixando-e-executando-uma-vm-fedora-no-virtualbox">2.1. Baixando e executando uma VM Fedora no VirtualBox</a></li>
<li><a href="#configurando-a-vm-para-acesso-a-partir-de-uma-console-do-host">2.2. Configurando a VM para acesso a partir de uma console do HOST</a></li>
<li><a href="#instalando-o-docker">2.3. Instalando o Docker</a></li>
</ul>
</li>
<li><a href="#primeiros-passos-na-utilização-do-docker">3. Primeiros passos na utilização do Docker</a>
<ul class="sectlevel2">
<li><a href="#procurando-contêineres-no-docker-hub">3.1. Procurando contêineres no Docker Hub</a></li>
<li><a href="#docker-hello-world">3.2. Docker Hello World</a></li>
<li><a href="#por-dentro-de-um-contêiner">3.3. Por dentro de um contêiner</a></li>
<li><a href="#gerenciamento-básico-de-um-contêiner">3.4. Gerenciamento básico de um contêiner</a></li>
</ul>
</li>
<li><a href="#docker-em-projetos-jboss">4. Docker em projetos JBoss</a>
<ul class="sectlevel2">
<li><a href="#wildfly-no-docker">4.1. WildFly no Docker</a>
<ul class="sectlevel3">
<li><a href="#executando-em-modo-standalone">4.1.1. Executando em modo standalone</a></li>
<li><a href="#executando-em-modo-domain">4.1.2. Executando em modo domain</a></li>
<li><a href="#explorando-mais">4.1.3. Explorando mais</a></li>
</ul>
</li>
<li><a href="#rhq-no-docker">4.2. RHQ no Docker</a></li>
</ul>
</li>
<li><a href="#para-reiniciar-este-tutorial">5. Para reiniciar este tutorial</a></li>
</ul>
</div>
</div>
<div class="sect1">
<h2 id="background-teórico-sobre-o-docker"><a class="anchor" href="#background-teórico-sobre-o-docker"></a>1. Background teórico sobre o Docker</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="o-que-é-o-docker"><a class="anchor" href="#o-que-é-o-docker"></a>1.1. O que é o Docker?</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.docker.com/whatisdocker/" class="bare">https://www.docker.com/whatisdocker/</a></p>
</li>
<li>
<p><a href="https://www.docker.com/tryit/" class="bare">https://www.docker.com/tryit/</a></p>
</li>
<li>
<p>Plataforma aberta para desenvolvedores e sysadmins</p>
<div class="ulist">
<ul>
<li>
<p>Para construir, implantar e executar aplicações distribuídas</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="porque-os-desenvolvedores-gostam-dele"><a class="anchor" href="#porque-os-desenvolvedores-gostam-dele"></a>1.1.1. Porque os desenvolvedores gostam dele?</h4>
<div class="ulist">
<ul>
<li>
<p>Desenvolvedores utilizam o docker para criar aplicações que rodam de maneira padrão em qualquer lugar:</p>
<div class="ulist">
<ul>
<li>
<p>Laptops com OS X, Linux e, até mesmo (pasmem) Windows</p>
</li>
<li>
<p>Servidores na nuvem rodando Ubuntu, Red Hat, &#8230;&#8203;</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="porque-os-sysadmins-gostam-dele"><a class="anchor" href="#porque-os-sysadmins-gostam-dele"></a>1.1.2. Porque os sysadmins gostam dele?</h4>
<div class="ulist">
<ul>
<li>
<p>Sysadmins utilizam o docker para prover ambientes para times de:</p>
<div class="ulist">
<ul>
<li>
<p>Desenvolvimento, Quality assurance (QA), produção</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="arquitetura"><a class="anchor" href="#arquitetura"></a>1.1.3. Arquitetura</h4>
<div class="ulist">
<ul>
<li>
<p>O docker possui uma arquitetura cliente/servidor</p>
</li>
<li>
<p><a href="https://docs.docker.com/introduction/understanding-docker/#the-docker-client">Docker client</a> conversa com <a href="https://docs.docker.com/introduction/understanding-docker/#the-docker-daemon">Docker daemon</a></p>
<div class="ulist">
<ul>
<li>
<p>Client pode se conectar a um daemon remoto ou local (mesmo sistema)</p>
</li>
<li>
<p>Client e daemon se comunicam via sockets ou através de uma API RESTful</p>
</li>
<li>
<p>Client aceita comandos do usuário e faz a comunicação com o daemon</p>
</li>
</ul>
</div>
</li>
<li>
<p>Docker daemon executa na máquina Host</p>
<div class="ulist">
<ul>
<li>
<p>O usuário nunca interage diretamente com o daemon mas sim com o client</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="https://docs.docker.com/article-img/architecture.svg" alt="Architecture">
</div>
</div>
</div>
<div class="sect3">
<h4 id="componentes-internos"><a class="anchor" href="#componentes-internos"></a>1.1.4. Componentes internos</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.docker.com/introduction/understanding-docker/#inside-docker">Docker images</a></p>
<div class="ulist">
<ul>
<li>
<p>São templates (somente leitura)</p>
<div class="ulist">
<ul>
<li>
<p>Podem conter um sistema operacional e aplicações instaladas</p>
</li>
</ul>
</div>
</li>
<li>
<p>São utilizadas para criar contêineres</p>
</li>
</ul>
</div>
</li>
<li>
<p>Docker Registries</p>
<div class="ulist">
<ul>
<li>
<p>Armazenam imagens docker</p>
<div class="ulist">
<ul>
<li>
<p>Provêem upload e download de imagens docker</p>
</li>
</ul>
</div>
</li>
<li>
<p>São privados ou públicos</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://hub.docker.com/">Docker Hub</a> é o registry público</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Docker contêineres</p>
<div class="ulist">
<ul>
<li>
<p>São similares a diretórios</p>
</li>
<li>
<p>Armazenam tudo o que é necessário para uma aplicação ser executada</p>
</li>
<li>
<p>São executados, iniciados, parados, movidos e removidos</p>
</li>
<li>
<p>Cada contêiner é uma plataforma segura e isolada de aplicações</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="como-o-docker-funciona"><a class="anchor" href="#como-o-docker-funciona"></a>1.1.5. Como o Docker funciona?</h4>
<div class="ulist">
<ul>
<li>
<p>Você contrói imagens que armazenam suas aplicações</p>
</li>
<li>
<p>Você cria contêineres a partir dessas imagens para executar suas aplicações</p>
</li>
<li>
<p>Você compartilha suas imagens via Docker Hub ou no seu próprio registry</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="instalando-o-docker-no-fedora"><a class="anchor" href="#instalando-o-docker-no-fedora"></a>2. Instalando o Docker no Fedora</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Os passos para a instalação do Docker num Fedora são descritos na página <a href="http://docs.docker.com/installation/fedora/" class="bare">http://docs.docker.com/installation/fedora/</a>. Também gosto de referenciar <a href="https://goldmann.pl/blog/2013/09/25/docker-and-fedora/">um post do Marek Goldman relativo a essa questão</a>.</p>
</div>
<div class="paragraph">
<p>O Docker pode ser executado numa máquina virtual (VM) ou real. O fato é que ele foi desenvolvido para rodar num kernel Linux executando numa arquitetura de 64 bits.</p>
</div>
<div class="sect2">
<h3 id="baixando-e-executando-uma-vm-fedora-no-virtualbox"><a class="anchor" href="#baixando-e-executando-uma-vm-fedora-no-virtualbox"></a>2.1. Baixando e executando uma VM Fedora no VirtualBox</h3>
<div class="paragraph">
<p>Para seguirmos este tutorial, utilizaremos uma VM que executará um Fedora 20 x86_64. Eu utilizarei o OS X para rodar essa VM no <a href="http://virtualbox.org">VirtualBox</a>. Se for o caso, você também pode utilizar um Linux para seguir esse tutorial ou até mesmo um Windows com um <a href="http://cygwin.com">Cygwin</a> instalado. Não é problema. Mas, talvez você precise adaptar alguns dos comandos que apresentarei.</p>
</div>
<div class="paragraph">
<p>Então, faremos o download, extrairemos e executaremos <a href="http://gdriv.es/vm-fedora">minha vm-fedora</a> (<a href="https://github.com/paulojeronimo/vms/">leia os procedimentos que escrevi para criá-la</a> se desejar mais detalhes a seu respeito). Para descompactar essa VM, precisaremos do <a href="http://7zip.org">7zip</a> instalado e seguiremos os seguintes passos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">cd ~/VirtualBox\ VMs/
bash &lt;(curl -L http://j.mp/vm-fedora-download)
7za x vm-fedora.7z.001
VBoxManage registervm "$PWD/vm-fedora/vm-fedora.vbox"
VBoxManage startvm vm-fedora</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Observação: poderíamos utilizar o <a href="https://www.vagrantup.com/">Vagrant</a> (leia <a href="http://paulojeronimo.github.io/tutorial-vagrant/">o tutorial que escrevi a seu respeito</a>) mas, neste tutorial, não estou utilizando-o.</em></p>
</div>
</div>
<div class="sect2">
<h3 id="configurando-a-vm-para-acesso-a-partir-de-uma-console-do-host"><a class="anchor" href="#configurando-a-vm-para-acesso-a-partir-de-uma-console-do-host"></a>2.2. Configurando a VM para acesso a partir de uma console do HOST</h3>
<div class="paragraph">
<p>A VM que baixamos só possui uma interface de rede (configurada com o IP 10.0.2.5). A partir dela conseguimos navegar na Internet através de um NAT com a máquina HOST (nossa máquina, que está executando o VirtualBox). Tecnicamente, não há como fazer um ping ou mesmo acesar o IP da VM através da máquina HOST, nesse caso. Mas, há uma alternativa para isso que consiste na criação de um túnel reverso fazendo um ssh da console da VM para o HOST. Para testarmos essa alternativa, loguemos no console da VM (usuário <code>aluno</code>, senha <code>@lun0123</code>) e executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ssh -f -N -R 2222:localhost:22 pj@base</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Obviamente, você deverá substituir o meu usuário (<code>pj</code>) pelo o usuário que você tem em tua máquina. Detalhe: o host <code>base</code> tem o IP 10.0.2.2, que é o IP NAT padrão configurado no HOST pelo VirtualBox</em>.</p>
</div>
<div class="paragraph">
<p>Dessa forma, a partir de um shell aberto no HOST, poderíamos acessar a VM com os seguintes comandos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ssh-copy-id -p 2222 aluno@localhost
ssh -p 2222 aluno@localhost</pre>
</div>
</div>
<div class="paragraph">
<p>O problema de fazer isso é que, mais a frente nesse tutorial, testaremos o acesso ao WildFly através de um IP válido para o HOST ao invés de fazermos túneis para as portas utilizadas pelo WildFly. Por isso precisaremos parar a VM e fazer algumas configurações. Adicionaremos uma rede de comunicação entre o HOST e a VM ajustando o IP 192.168.0.253 para o HOST. Também criaremos uma nova interface de rede na VM e configuraremos um IP para ela.</p>
</div>
<div class="paragraph">
<p>Encerrando o ssh com a VM (<span class="keyseq"><kbd>Ctrl</kbd>+<kbd>D</kbd></span>) e voltando para o console do HOST, paremos a execução da VM:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">VBoxManage controlvm vm-fedora acpipowerbutton</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aguardemos a VM ser finalizada e, assim que isso ocorrer, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">VBoxManage hostonlyif create
VBoxManage hostonlyif ipconfig vboxnet0 --ip 192.168.0.253 --netmask 255.255.255.0
VBoxManage modifyvm vm-fedora --nic2 hostonly --hostonlyadapter2 vboxnet0
VBoxManage startvm vm-fedora
f=/etc/hosts; grep -v vm-fedora $f | sudo tee $f
echo -e "192.168.0.254\tvm-fedora" | sudo tee -a $f
cat $f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Façamos mais uma vez o logon na console da VM como usuário <code>aluno</code>. Executemos novamente o comando de criação do túnel reverso (<em>sugestão: utilize um <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>R</kbd></span> para encontrá-lo</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ssh -f -N -R 2222:localhost:22 pj@base</code></pre>
</div>
</div>
<div class="paragraph">
<p>Observemos que, agora, há uma nova interface de rede nessa máquina (<code>p7p1</code>). Vejamos isso através da execução do comando a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ip a s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Precisamos configurar um IP estático para essa nova interface. Será esse IP que utilizaremos termos o acesso do HOST na VM. De volta ao console da máquina HOST, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ssh -p 2222 aluno@localhost</code></pre>
</div>
</div>
<div class="paragraph">
<p>Temos acesso remoto para a console da VM utilizando nosso HOST. Copiemos e colemos os comandos a seguir nessa console (<em>detalhe: copia/colar não seria possível de fazer, diretamente, do HOST para a VM pois o VirtualBox não oferece esta facilidade quando estamos trabalhando no modo texto, o que é o caso</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">cat &lt;&lt;'EOF' | sudo tee /etc/sysconfig/network-scripts/ifcfg-static-p7p1
DEVICE=p7p1
BOOTPROTO=none
ONBOOT=yes
IPADDR=192.168.0.254
PREFIX=24
GATEWAY=192.168.0.254
EOF
sudo nmcli con reload
sudo nmcli con up "System static-p7p1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Os comandos executados acima servem para configurar o IP estático 192.168.0.254 para a interface <code>p7p1</code>. É com esse IP que iremos acessar a VM, que nomeamos <code>vm-fedora</code> no arquivo /etc/hosts da nossa máquina HOST. Para verificar se tudo deu certo, façamos um ping para IP 192.168.0.253 do HOST:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ping 192.168.0.253</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por fim, instalemos alguns utilitários que serão utilizados no decorrer desse tutorial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>sudo yum -y install vim tree lynx</pre>
</div>
</div>
<div class="paragraph">
<p>Voltemos ao console do HOST digitando um <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>D</kbd></span> e, em seguida, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ping vm-fedora
ssh aluno@vm-fedora</code></pre>
</div>
</div>
<div class="paragraph">
<p>De agora em diante, executaremos todos os procedimentos que apresentarei no console da VM (a menos que eu dê alguma outra instrução).</p>
</div>
</div>
<div class="sect2">
<h3 id="instalando-o-docker"><a class="anchor" href="#instalando-o-docker"></a>2.3. Instalando o Docker</h3>
<div class="paragraph">
<p>Façamos a instalação do Docker (e a configuração para sua inicialização automática) com os seguintes comandos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo yum -y install docker-io
sudo systemctl start docker
sudo systemctl enable docker</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="primeiros-passos-na-utilização-do-docker"><a class="anchor" href="#primeiros-passos-na-utilização-do-docker"></a>3. Primeiros passos na utilização do Docker</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="procurando-contêineres-no-docker-hub"><a class="anchor" href="#procurando-contêineres-no-docker-hub"></a>3.1. Procurando contêineres no Docker Hub</h3>
<div class="paragraph">
<p>Busquemos contêineres executando as instruções a seguir. O <code>| less</code> após o <code>docker search</code> é interessante pois serão listadas várias imagens.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker search fedora | less
sudo docker search wildfly | less
sudo docker search rhq | less</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docker-hello-world"><a class="anchor" href="#docker-hello-world"></a>3.2. Docker Hello World</h3>
<div class="paragraph">
<p>Executemos o "Docker Hello World":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run fedora echo 'Hello World'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obervamos que a execução do comando acima fez o download da imagem <code>fedora</code> e, em seguida, imprimiu um <code>Hello World</code> na console da VM. Toda a execução de uma imagem é um contêiner e fica registrada pelo Docker. Podemos ver esse registro através do comando a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker ps -a</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se repetirmos o primeiro comando teremos a criação de um novo contêiner. Experimentemos isso, executando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">!-2
!-2</code></pre>
</div>
</div>
<div class="paragraph">
<p>A saída do último comando deve nos apresentar uma listagem como esta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                      PORTS               NAMES
3568e2848ea9        fedora:latest       "echo 'Hello World'"   15 seconds ago      Exited (0) 14 seconds ago                       drunk_bartik
de9be19a40a4        fedora:latest       "echo 'Hello World'"   33 seconds ago      Exited (0) 32 seconds ago                       boring_ardinghelli</code></pre>
</div>
</div>
<div class="paragraph">
<p>Removamos os dois contêineres criados, executando o comando a seguir (<em>adeque o comando de acordo com os ids apresentados na sua saída que você obteve; note também que, se não houverem repetições, apenas os três primeiros dígitos do 'Container ID' bastam para que o docker consiga identificá-lo</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker rm 356 de9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Podemos pedir ao Docker que remova o contêiner de seu registro logo após o término de sua execução. Para testarmos isso, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run --rm fedora echo 'Hello World'
sudo docker ps -a</code></pre>
</div>
</div>
<div class="paragraph">
<p>Concluindo, notamos que a adição do parâmetro <code>--rm</code> ao comando <code>docker run</code> elimina o registro do contêiner no Docker.</p>
</div>
</div>
<div class="sect2">
<h3 id="por-dentro-de-um-contêiner"><a class="anchor" href="#por-dentro-de-um-contêiner"></a>3.3. Por dentro de um contêiner</h3>
<div class="paragraph">
<p>Executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run -i -t fedora /bin/bash</code></pre>
</div>
</div>
<div class="paragraph">
<p>Os parâmetros passados ao docker significam o seguinte:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>run</code> - executa um contêiner (como vimos anteriormente);</p>
</li>
<li>
<p><code>-i</code> - mantem o stdin aberto, mesmo que não haja nada anexado;</p>
</li>
<li>
<p><code>-t</code> - aloca um pseudo terminal, dessa forma podermos interagir diretamente com o contêiner;</p>
</li>
<li>
<p><code>fedora</code> - ID da imagem, pode ser uma tag ou um hash (id);</p>
</li>
<li>
<p><code>/bin/bash</code> - o comando que será executado após o contêiner ser iniciado;</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Alguns detalhes que podemos observar sobre a execução desse comando:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se a imagem do contêiner não estiver no cache local ela será baixada (nessa execução ela já estava no cache);</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Se quiséssesmos apenas baixar a imagem, sem criar nenhum contêiner, poderíamos simplesmente executar o comando <code>sudo docker pull fedora</code>;</p>
</li>
</ol>
</div>
</li>
<li>
<p>O prompt de comando apresentado será da forma root@&lt;id&gt;;</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Como estamos dentro do contêiner, executemos alguns comandos para observar seu comportamento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ls -la
ps -ef
env | grep -i hostname
ip a s
df -h
free -m</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pela saída dos comandos acima, notamos várias coisas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>O contêiner tem um sistema de arquivos próprio e independente do host;</p>
</li>
<li>
<p>O contêiner só está executando o comando que lhe foi solicitado executar;</p>
</li>
<li>
<p>O nome configurado para o contêiner é o seu id;</p>
</li>
<li>
<p>Há duas interfaces de rede configuradas: a de loopback, e outra com um IP específico;</p>
</li>
<li>
<p>O espaço em disco alocado para a partição root (/) é de 9.8G;</p>
</li>
<li>
<p>A memória alocada para o contêiner tem o mesmo tamanho que a memória alocada para a VM;</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Criemos um arquivo temporário e façamos a instalação de um pacote:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">echo 'Teste' &gt; /tmp/teste
yum -y install tree</code></pre>
</div>
</div>
<div class="paragraph">
<p>Paremos o contêiner pressionando <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>D</kbd></span>. Ele será parado mas poderá ser reiniciado ou removido na hora que quisermos.</p>
</div>
</div>
<div class="sect2">
<h3 id="gerenciamento-básico-de-um-contêiner"><a class="anchor" href="#gerenciamento-básico-de-um-contêiner"></a>3.4. Gerenciamento básico de um contêiner</h3>
<div class="paragraph">
<p>Para removermos o contêiner, vimos que precisaremos saber seu id e para isso, executamos um <code>sudo docker ps</code>. A saída desse comando, entretanto, só nos mostra os ids dos contêineres em execução. Para listarmos os ids de todos os contêineres, até mesmo os que não estão em execução, executaremos esse mesmo comando informando o parâmetro <code>-a</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker ps -a</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nossa saída deverá ser similar a esta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
d30ae9376851        fedora:latest       "/bin/bash"         27 minutes ago      Exited (0) 24 minutes ago                       drunk_curie</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para vermos que arquivos foram adicionados, removidos ou modificados no contêiner, executemos (<em>substitua o id que informo abaixo pelo que é apresentado na tua saída para o comando acima</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker diff d30</code></pre>
</div>
</div>
<div class="paragraph">
<p>Removamos o contêiner:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker rm d30</code></pre>
</div>
</div>
<div class="paragraph">
<p>Criemos um novo contêiner com o seguinte comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run -it -p 4242:4242 fedora /bin/bash</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em relação ao que já discutimos, a única diferença é a adição do parâmetro <code>-p</code> na linha de comando. Ele serve para informar que haverá um redirecionamento da porta 4242 da VM para o contêiner. Isso é necessário pois, mais a frente, acessaremos a URL <a href="http://vm-fedora:4242" class="bare">http://vm-fedora:4242</a>.</p>
</div>
<div class="paragraph">
<p>Agora criaremos um contêiner que seja capaz de fazer a construção deste site que estamos lendo e, em seguida, geraremos uma imagem desse contêiner para fazer seu upload no Docker Hub. Nosso primeiro passo será instalar o <a href="http://ruby-lang.org">Ruby</a> 2.1 dentro desse contêinter, utilizando o <a href="http://rvm.io/">RVM</a> e seguindo os seguintes passos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">yum -y install which
curl -sSL https://get.rvm.io | sudo -E bash -s stable
source /etc/profile.d/rvm.sh
rvm install 2.1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Verifiquemos se a instalação do Ruby foi bem sucedida:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ruby -v</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este site, <a href="./index.html">como eu disse</a>, foi construído com o uso do <a href="http://awestruct.org">Awestruct</a> e do <a href="http://asciidoctor.org">Asciidoctor</a>. O Asciidoctor é instalado automaticamente quando instalamos o Awestruct. Esse último, por sua vez, tem outras dependências como o <a href="http://www.nokogiri.org/">Nokogiri</a>. No Fedora, para que o Nokogiri seja instalado, precisamos instalar alguns pacotes a mais. Executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">yum -y install libxml2-devel libxslt-devel</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instalemos o Awestruct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">gem install awestruct</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para que possamos obter a versão mais atual deste site com o objetivo de fazermos sua contrução, também precisaremos instalar o <a href="http://git-scm.com/">Git</a>. Executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">yum -y install git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora nosso contêiner tem tudo o que precisamos para construir este site. Mas, ainda precisamos testar essa construção baixando sua versão mais atual <a href="http://github.com/paulojeronimo/JUDCon-2014-Brazil">publicada no GitHub</a>. Executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">useradd -G rvm -m -s /bin/bash judcon
su - judcon
git clone http://github.com/paulojeronimo/JUDCon-2014-Brazil
cd JUDCon-2014-Brazil
rvm use 2.1@JUDCon-2014-Brazil --create --ruby-version
bundle install
rake</code></pre>
</div>
</div>
<div class="paragraph">
<p>Os comandos acima fizeram a adição do usuário <code>judcon</code>. Também fizeram o <code>root</code> se logar como ele, clonaram a <a href="http://github.com/paulojeronimo/JUDCon-2014-Brazil">última versão publicada do meu repositório JUDCon-2014-Brazil no GitHub</a>, entraram no diretório clonado e solicitaram a construção do site pela execução do Awestruct.</p>
</div>
<div class="paragraph">
<p>Antes de parar esse contêiner, testemos o acesso a URL <a href="http://vm-fedora:4242" class="bare">http://vm-fedora:4242</a>.</p>
</div>
<div class="paragraph">
<p>Se conseguirmos fazer esse acesso e verificamos o site em execução, estamos prontos para gerar a imagem do contêiner!</p>
</div>
<div class="paragraph">
<p>Conseguimos! Agora, geremos a imagem do contêiner. Para isso, paremos sua execução. Para isso, dêmos um <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>C</kbd></span> na execução do comando em execução (<code>rake</code>). Em seguida, façamos o logout do usuário judcon (dititando um <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>D</kbd></span>). Por fim, encerremos o contêiner (mais um <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>D</kbd></span>).</p>
</div>
<div class="paragraph">
<p>Queremos transformar as alterações que fizemos nesse contêiner numa imagem. Dessa forma poderemos gerar novos contêineres a partir dela e esses já conterão todas as ferramentas que precisamos para fazer a reconstrução de <a href="http://paulojeronimo.github.io/JUDCon-2014-Brazil">nosso site JUDCon-2014-Brazil</a>. Nosso próximo passo será fazer um <code>commit</code> das mudanças que fizemos no contêiner e isso pode ser realizado com a execução dos seguintes comandos (<em>substitua a string que representa meu usuário (<code>paulojeronimo</code>) por outro nome de tua preferência</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">CID=$(sudo docker ps -a | sed -n '2p' | cut -d ' ' -f 1)
sudo docker commit $CID paulojeronimo/judcon-2014-brazil</code></pre>
</div>
</div>
<div class="paragraph">
<p>A execução desse <code>commit</code> demora um pouquinho. Mas, nada que nos atrapalhe significativamente. Além disso, esse tempo de construção da imagem só foi um pouco demorado em virtude de termos realizado várias mudanças em relação a imagem original (<code>fedora</code>) somando a ela muitos pacotes e mudanças no sistema de arquivos. Como resultado dos comandos acima, agora temos uma nova imagem nomeada <code>paulojeronimo/judcon-2014-brazil</code> (ou <em>teu-nome/judcon-2014-brazil</em>). Confiramos isso com a execução do seguinte comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker images</code></pre>
</div>
</div>
<div class="paragraph">
<p>Podemos remover o contêiner que nos serviu de base para a criação da imagem e, em seguida, criar um novo contêiner para testarmos a construção de nosso site. Para isso, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker rm $CID
sudo docker run -it --rm -p 4242:4242 paulojeronimo/judcon-2014-brazil /bin/bash</code></pre>
</div>
</div>
<div class="paragraph">
<p>Após obtermos o prompt do contêiner, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">su - judcon
cd JUDCon-Brazil-2014
rake</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, testemos o acesso ao site gerado acessando a URL <a href="http://vm-fedora:4242" class="bare">http://vm-fedora:4242</a>.</p>
</div>
<div class="paragraph">
<p>Encerremos a execução do contêiner repetindo os passos que executamos antes de gerarmos sua imagem.</p>
</div>
<div class="paragraph">
<p>Agora, queremos publicar nossa imagem no Docker Hub para que outras pessoas possam utilizá-la, assim como nós fizemos. Para isso, nosso primeiro passo para isso deve ser efetuar o logon nesse serviço. <em>(É óbvio que se você ainda não possui uma conta no Docker Hub, você deve criá-la primeiro!)</em></p>
</div>
<div class="paragraph">
<p>Executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker login</code></pre>
</div>
</div>
<div class="paragraph">
<p>Seremos solicitados a informar um usuário, uma senha e um email. Por fim, executemos o comando a seguir para subir a imagem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker push paulojeronimo/judcon-2014-brazil</code></pre>
</div>
</div>
<div class="paragraph">
<p>O processo de upload pode demorar um pouco dependendo do tamanho da imagem que você está subindo para o Docker Hub. De qualquer forma, após publicada a imagem fica disponível numa URL como essa: <a href="https://registry.hub.docker.com/u/paulojeronimo/judcon-2014-brazil/" class="bare">https://registry.hub.docker.com/u/paulojeronimo/judcon-2014-brazil/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="docker-em-projetos-jboss"><a class="anchor" href="#docker-em-projetos-jboss"></a>4. Docker em projetos JBoss</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vários projetos do grupo JBoss estão utilizando o Docker. Leia mais sobre isso nos seguintes links:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.jboss.org/docker/" class="bare">http://www.jboss.org/docker/</a></p>
</li>
<li>
<p><a href="https://goldmann.pl/blog/2014/07/08/jboss-projects-as-docker-images/" class="bare">https://goldmann.pl/blog/2014/07/08/jboss-projects-as-docker-images/</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Neste tutorial, executaremos apenas dois projetos JBoss no Docker: o WildFly e o RHQ. Mas, nos links acima há receitas para a execução de outros projetos.</p>
</div>
<div class="sect2">
<h3 id="wildfly-no-docker"><a class="anchor" href="#wildfly-no-docker"></a>4.1. WildFly no Docker</h3>
<div class="paragraph">
<p>As instruções para o boot do WildFly no Docker estão na página <a href="https://registry.hub.docker.com/u/jboss/wildfly/" class="bare">https://registry.hub.docker.com/u/jboss/wildfly/</a>.</p>
</div>
<div class="sect3">
<h4 id="executando-em-modo-standalone"><a class="anchor" href="#executando-em-modo-standalone"></a>4.1.1. Executando em modo standalone</h4>
<div class="paragraph">
<p>Executar o WildFly no modo standalone com o Docker é simples assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run -it --rm jboss/wildfly</code></pre>
</div>
</div>
<div class="paragraph">
<p>Contudo, temos um problema: como acessar uma aplicação executando num contêiner? (Essa aplicação poderia ser, por exemplo, a própria interface administrativa do WildFly).</p>
</div>
<div class="paragraph">
<p>Para acessar o WildFly na porta 8080 (dentro da VM), é necessário descobrir o IP do contêiner. Façamos essa descoberta abrindo um novo console na VM e executando os seguintes comandos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">CID=$(sudo docker ps -a | grep -i up | awk '{print $1}'); echo CID</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esse primeiro comando serve para que possamos recuperar o identificador do contêiner (<em>Container ID</em>) e armazená-lo na variável <code>CID</code>. De posse desse identificador, podemos inspecionar o contêiner em busca do IP que o Docker associou a ele executando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">IP=$(sudo docker inspect --format '{{ .NetworkSettings.IPAddress }}' $CID); echo $IP</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora, sabemos o IP. Poderemos abrir um browser dentro da VM e acessar a URL <a href="http://$IP:8080" class="bare">http://$IP:8080</a>. O problema é que não temos uma interface gráfica instalada nessa VM para rodar um browser como o Firefox, por exemplo. Outra questão é que o IP obtido para o contêiner também só é acessível de dentro da VM! Então, para contornar esta situação, testemos o acesso a essa URL utilizando um browser em modo texto (lynx), executando-o na própria linha de comando da VM:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">lynx http://$IP:8080</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para acessarmos o WildFly a partir do HOST a solução é pedir que o docker crie mais dois túneis de acesso (para as portas 8080 e 9990) entre a VM e o contêiner. Façamos isso encerrando a execução corrente do WildFly (dando um <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>C</kbd></span> na sua console) e, em seguida, executando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run -it --rm -p 8080:8080 -p 9990:9990 jboss/wildfly</code></pre>
</div>
</div>
<div class="paragraph">
<p>Podemos agora acessar, do HOST, a URL <a href="http://vm-fedora:8080" class="bare">http://vm-fedora:8080</a>. Só que para acessarmos a interface administrativa, ainda precisamos da adição um usuário administrativo. Modificaremos nosso contêiner adionando esse usuário.</p>
</div>
<div class="paragraph">
<p>Paremos novamente o contêiner em execução (<span class="keyseq"><kbd>Ctrl</kbd>+<kbd>C</kbd></span>) e executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">mkdir -p ~/demos/01-wildfly-management
cd !$
cat &gt; Dockerfile &lt;&lt;EOF
FROM jboss/wildfly
RUN /opt/wildfly/bin/add-user.sh admin Admin#70365 --silent
EOF
sudo docker build -t wildfly-management .</code></pre>
</div>
</div>
<div class="paragraph">
<p>O que fizemos agora foi criar uma imagem própria, derivada da imagem <code>jboss/wildfly</code>, onde apenas adicionamos as configurações necessárias para a inclusão de um usuário de administração do WildFly.</p>
</div>
<div class="paragraph">
<p>Executemos o comando <code>sudo docker images</code>. Com isso, obteremos a seguinte saída:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>REPOSITORY           TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
wildfly-management   latest              31961a1179fa        20 seconds ago      929 MB
fedora               latest              7d3f07f8de5f        About an hour ago   374.1 MB
jboss/wildfly        latest              bf5508a3f1c7        12 hours ago        929 MB</code></pre>
</div>
</div>
<div class="paragraph">
<p>Executemos novamente o WildFly de forma que, agora, consigamos acesso a sua interface administrativa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run -it --rm -p 8080:8080 -p 9990:9990 wildfly-management</code></pre>
</div>
</div>
<div class="paragraph">
<p>Recarregando a URL <a href="http://vm-fedora:8080" class="bare">http://vm-fedora:8080</a> no HOST, teremos acesso a console de administração após informar o usuário <code>admin</code> e a senha <code>Admin#70365</code>.</p>
</div>
<div class="paragraph">
<p>O Docker nos oferece uma forma de visualizar as diferenças entre a imagem (somente leitura) e o contêiner. Para isso, precisamos executar um <code>docker ps -a</code> (façamos isso em outra console da VM, enquanto o WildFly está executando). Sua saída será similar a esta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CONTAINER ID        IMAGE                       COMMAND                CREATED             STATUS                           PORTS                                            NAMES
23661d0835ee        wildfly-management:latest   "/opt/wildfly/bin/st   45 minutes ago      Up 45 minutes                    0.0.0.0:8080-&gt;8080/tcp, 0.0.0.0:9990-&gt;9990/tcp   naughty_archimedes
aa4272a565ca        jboss/wildfly:latest        "/opt/wildfly/bin/st   About an hour ago   Exited (130) 55 minutes ago                                                       dreamy_nobel
746e8e569540        jboss/wildfly:latest        "/opt/wildfly/bin/st   About an hour ago   Exited (130) About an hour ago                                                    tender_tesla
75653974d524        fedora:latest               "/bin/bash"            About an hour ago   Exited (0) About an hour ago                                                      agitated_goodall</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notemos a coluna <code>NAMES</code> nessa saída e utilizemos o seu valor para o contêiner 236 (primeiros três dígitos do <code>CONTAINER ID</code>), na execução do comando a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker diff naughty_archimedes</code></pre>
</div>
</div>
<div class="paragraph">
<p>A saída desse comando, apresentada abaixo, lista as mudanças no sistema de arquivos, em relação a imagem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>C /opt/wildfly-8.1.0.Final/standalone
C /opt/wildfly-8.1.0.Final/standalone/configuration
C /opt/wildfly-8.1.0.Final/standalone/configuration/logging.properties
A /opt/wildfly-8.1.0.Final/standalone/configuration/standalone_xml_history
A /opt/wildfly-8.1.0.Final/standalone/configuration/standalone_xml_history/current
A /opt/wildfly-8.1.0.Final/standalone/configuration/standalone_xml_history/snapshot
A /opt/wildfly-8.1.0.Final/standalone/configuration/standalone_xml_history/standalone.boot.xml
A /opt/wildfly-8.1.0.Final/standalone/configuration/standalone_xml_history/standalone.initial.xml
A /opt/wildfly-8.1.0.Final/standalone/configuration/standalone_xml_history/standalone.last.xml
A /opt/wildfly-8.1.0.Final/standalone/data
A /opt/wildfly-8.1.0.Final/standalone/data/content
A /opt/wildfly-8.1.0.Final/standalone/data/timer-service-data
A /opt/wildfly-8.1.0.Final/standalone/data/tx-object-store
A /opt/wildfly-8.1.0.Final/standalone/data/tx-object-store/ShadowNoFileLockStore
A /opt/wildfly-8.1.0.Final/standalone/data/tx-object-store/ShadowNoFileLockStore/defaultStore
A /opt/wildfly-8.1.0.Final/standalone/log
A /opt/wildfly-8.1.0.Final/standalone/log/server.log
C /opt/wildfly-8.1.0.Final/standalone/tmp
A /opt/wildfly-8.1.0.Final/standalone/tmp/vfs
A /opt/wildfly-8.1.0.Final/standalone/tmp/vfs/temp
C /tmp/hsperfdata_wildfly
A /tmp/hsperfdata_wildfly/53</code></pre>
</div>
</div>
<div class="paragraph">
<p>Paremos o WidlFly dando um <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>C</kbd></span> na console em que ele está sendo executando.</p>
</div>
<div class="paragraph">
<p>Existe um comando no Docker que podemos rodar para ver o histório de uma imagem. Executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker history wildfly-management</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora vamos criar uma nova imagem, adicionando um pacote que deverá ser implantado (feito o <em>deploy</em>), automaticamente, quando instanciarmos o WildFly. Executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">mkdir -p ~/demos/02-wildfly-app
cd !$
cat &gt; Dockerfile &lt;&lt;'EOF'
FROM wildfly-management
ADD node-info.war /opt/wildfly/standalone/deployments/
EOF
#curl -O http://paulojeronimo.github.io/JUDCon-2014-Brazil/node-info.war
scp pj@base:~/Projects/github.com/goldmann/goldmann.pl/.presentations/2014-vjbug-docker/demos/03-bundle/node-info.war .
sudo docker build -t wildfly-app .</code></pre>
</div>
</div>
<div class="paragraph">
<p>Executemos novamente o comando para ver o histórico de uma imagem mas, dessa vez, informando o nome da imagem que derivamos de <code>wildfly-management</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker history wildfly-app</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notemos, pela saída do comando anterior, que a imagem wildfly-app cresceu (em espaço ocupado em disco) cerca de 8.000 kB. Esse é, aproximadamente, o tamanho do pacote que mandamos adicionar ao conteúdo da imagem.</p>
</div>
</div>
<div class="sect3">
<h4 id="executando-em-modo-domain"><a class="anchor" href="#executando-em-modo-domain"></a>4.1.2. Executando em modo domain</h4>
<div class="paragraph">
<p>Executemos o WildFly em modo domain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run -it --rm -p 8080:8080 -p 9990:9990 wildfly-app /opt/wildfly/bin/domain.sh -b 0.0.0.0 -bmanagement 0.0.0.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Observando a console de execução do WildFly, notamos que dois servidores (<code>server-one</code> e <code>server-two</code>) são iniciados (em poucos segundos) e alguns avisos aparecem.</p>
</div>
<div class="paragraph">
<p>Tentemos acessar a console de administração do WildFly através da URL <a href="http://vm-fedora:8080" class="bare">http://vm-fedora:8080</a>. Ooopss &#8230;&#8203; parece que caímos no problema de não termos um usuário administrativo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run -it --rm wildfly-app
bin/add-user.sh -dc domain/configuration/ -m -u admin -p Admin#70365 -s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em outro console, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker commit d953
sudo docker ps -a
sudo docker diff high_wilson</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="explorando-mais"><a class="anchor" href="#explorando-mais"></a>4.1.3. Explorando mais</h4>
<div class="paragraph">
<p>Dá para explorar várias coisas a mais &#8230;&#8203; Para isso, veja estas referências:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apresentação do Marek Goldmann no <a href="https://www.youtube.com/channel/UCrAKwbOeiDKtTShxLCKFvNg">Virtual JBoss User Group</a> (Setembro/2014):</p>
<div class="ulist">
<ul>
<li>
<p>Vídeo: <a href="https://www.youtube.com/watch?v=4uQ6gR_xZhE" class="bare">https://www.youtube.com/watch?v=4uQ6gR_xZhE</a></p>
</li>
<li>
<p>Exemplos: <a href="https://github.com/goldmann/goldmann.pl/tree/master/.presentations/2014-vjbug-docker/demos" class="bare">https://github.com/goldmann/goldmann.pl/tree/master/.presentations/2014-vjbug-docker/demos</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://goldmann.pl/blog/2014/03/06/creating-a-minimal-wildfly-docker-image/" class="bare">https://goldmann.pl/blog/2014/03/06/creating-a-minimal-wildfly-docker-image/</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rhq-no-docker"><a class="anchor" href="#rhq-no-docker"></a>4.2. RHQ no Docker</h3>
<div class="paragraph">
<p>O <a href="http://rhq.jboss.org/">RHQ</a> é um produto de monitoração que é a base para o <a href="http://www.redhat.com/en/technologies/jboss-middleware/operations-network">JON</a>. Para instalá-lo via Docker, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">git clone https://github.com/rhq-project/docker.git rhq-docker
cd !$/dockerfile
sudo ./build.sh
sudo ./run.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Explore mais detalhes nos seguintes links:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/rhq-project/docker" class="bare">https://github.com/rhq-project/docker</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=hx43fQh-RVQ&amp;feature=youtu.be" class="bare">https://www.youtube.com/watch?v=hx43fQh-RVQ&amp;feature=youtu.be</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="para-reiniciar-este-tutorial"><a class="anchor" href="#para-reiniciar-este-tutorial"></a>5. Para reiniciar este tutorial</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Removamos a vm-fedora:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>VBoxManage unregistervm vm-fedora --delete</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Removamos a interface hostonlyif:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre></pre>
</div>
</div>
</div>
</div></div><div class="footer"><div class="container"><p>Published site: <a href="http://paulojeronimo.github.io/JUDCon-2014-Brazil">http://paulojeronimo.github.io/JUDCon-2014-Brazil</a><br>Source code: <a href="http://github.com/paulojeronimo/JUDCon-2014-Brazil">http://github.com/paulojeronimo/JUDCon-2014-Brazil</a></p></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script><script src="http://paulojeronimo.github.io/JUDCon-2014-Brazil/js/bootstrap.min.js"></script></body></html>