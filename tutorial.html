<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"><title>PJ @ JUDCon 2014 Brazil</title><link href="http://paulojeronimo.github.io/JUDCon-2014-Brazil/css/bootstrap.min.css" rel="stylesheet"><link href="http://paulojeronimo.github.io/JUDCon-2014-Brazil/css/JUDCon-2014-Brazil.css" rel="stylesheet"></head><body><div class="navbar navbar-default navbar-fixed-top" role="navigation"><div class="container"><div class="navbar-header"><button class="navbar-toggle collapsed" data-target=".navbar-collapse" data-toggle="collapse" type="button"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="index.html">PJ @ JUDCon 2014 Brazil</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href="/JUDCon-2014-Brazil/tutorial.html">Tutorial</a></li><li><a href="/JUDCon-2014-Brazil/about.html">About</a></li><li><a href="/JUDCon-2014-Brazil/acknowledgments.html">Acknowledgments</a></li></ul></div></div></div><div class="container"><div class="sect1">
<h2 id="resumo"><a class="anchor" href="#resumo"></a>Resumo</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nesse tutorial eu explico fundamentos e conceitos para a execução do <a href="https://www.docker.com/">Docker</a> no <a href="https://fedoraproject.org/">Fedora 20</a>. Esses conceitos também se aplicam ao <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/">RHEL 7</a>. Então, eu exploro um caso de uso: a instalação e a configuração do <a href="http://wildfly.org/">WildFly</a> e do <a href="http://wildfly.org/">RHQ</a> nesse ambiente. Este tutorial foi projetado inicialmente para ser apresentado em <a href="http://www.jboss.org/events/JUDCon/2014/brazil/speakers.html#wildfly">minha palestra no JUDCon 2014 Brazil</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="background-teórico-sobre-o-docker"><a class="anchor" href="#background-teórico-sobre-o-docker"></a>Background teórico sobre o Docker</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="o-que-é-o-docker"><a class="anchor" href="#o-que-é-o-docker"></a>O que é o Docker?</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.docker.com/whatisdocker/" class="bare">https://www.docker.com/whatisdocker/</a></p>
</li>
<li>
<p><a href="https://www.docker.com/tryit/" class="bare">https://www.docker.com/tryit/</a></p>
</li>
<li>
<p>Plataforma aberta para desenvolvedores e sysadmins</p>
<div class="ulist">
<ul>
<li>
<p>Para construir, implantar e executar aplicações distribuídas</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="porque-os-desenvolvedores-gostam-dele"><a class="anchor" href="#porque-os-desenvolvedores-gostam-dele"></a>Porque os desenvolvedores gostam dele?</h4>
<div class="ulist">
<ul>
<li>
<p>Desenvolvedores utilizam o docker para criar aplicações que rodam de maneira padrão em qualquer lugar:</p>
<div class="ulist">
<ul>
<li>
<p>Laptops com OS X, Linux e, até mesmo (pasmem) Windows</p>
</li>
<li>
<p>Servidores na nuvem rodando Ubuntu, Red Hat, &#8230;&#8203;</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="porque-os-sysadmins-gostam-dele"><a class="anchor" href="#porque-os-sysadmins-gostam-dele"></a>Porque os sysadmins gostam dele?</h4>
<div class="ulist">
<ul>
<li>
<p>Sysadmins utilizam o docker para prover ambientes para times de:</p>
<div class="ulist">
<ul>
<li>
<p>Desenvolvimento, Quality assurance (QA), produção</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="arquitetura"><a class="anchor" href="#arquitetura"></a>Arquitetura</h4>
<div class="ulist">
<ul>
<li>
<p>O docker possui uma arquitetura cliente/servidor</p>
</li>
<li>
<p><a href="https://docs.docker.com/introduction/understanding-docker/#the-docker-client">Docker client</a> conversa com <a href="https://docs.docker.com/introduction/understanding-docker/#the-docker-daemon">Docker daemon</a></p>
<div class="ulist">
<ul>
<li>
<p>Client pode se conectar a um daemon remoto ou local (mesmo sistema)</p>
</li>
<li>
<p>Client e daemon se comunicam via sockets ou através de uma API RESTful</p>
</li>
<li>
<p>Client aceita comandos do usuário e faz a comunicação com o daemon</p>
</li>
</ul>
</div>
</li>
<li>
<p>Docker daemon executa na máquina Host</p>
<div class="ulist">
<ul>
<li>
<p>O usuário nunca interage diretamente com o daemon mas sim com o client</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="https://docs.docker.com/article-img/architecture.svg" alt="Architecture">
</div>
</div>
</div>
<div class="sect3">
<h4 id="componentes-internos"><a class="anchor" href="#componentes-internos"></a>Componentes internos</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.docker.com/introduction/understanding-docker/#inside-docker">Docker images</a></p>
<div class="ulist">
<ul>
<li>
<p>São templates (somente leitura)</p>
<div class="ulist">
<ul>
<li>
<p>Podem conter um sistema operacional e aplicações instaladas</p>
</li>
</ul>
</div>
</li>
<li>
<p>São utilizadas para criar contêineres</p>
</li>
</ul>
</div>
</li>
<li>
<p>Docker Registries</p>
<div class="ulist">
<ul>
<li>
<p>Armazenam docker images</p>
<div class="ulist">
<ul>
<li>
<p>Provêem upload e download de docker images</p>
</li>
</ul>
</div>
</li>
<li>
<p>São privados ou públicos</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://hub.docker.com/">Docker Hub</a> é o registry público</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Docker contêineres</p>
<div class="ulist">
<ul>
<li>
<p>São similares a diretórios</p>
</li>
<li>
<p>Armazenam tudo o que é necessário para uma aplicação ser executada</p>
</li>
<li>
<p>São executados, iniciados, parados, movidos e removidos</p>
</li>
<li>
<p>Cada contêiner é uma plataforma segura e isolada de aplicações</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="como-o-docker-funciona"><a class="anchor" href="#como-o-docker-funciona"></a>Como o Docker funciona?</h4>
<div class="ulist">
<ul>
<li>
<p>Você faz o build de images que armazenam suas aplicações</p>
</li>
<li>
<p>Você cria contêineres a partir desses images para executar suas aplicações</p>
</li>
<li>
<p>Você compartilha suas images via Docker Hub ou no seu próprio registry</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="instalando-o-docker-no-fedora"><a class="anchor" href="#instalando-o-docker-no-fedora"></a>Instalando o Docker no Fedora</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="http://docs.docker.com/installation/fedora/" class="bare">http://docs.docker.com/installation/fedora/</a></p>
</li>
<li>
<p><a href="https://goldmann.pl/blog/2013/09/25/docker-and-fedora/" class="bare">https://goldmann.pl/blog/2013/09/25/docker-and-fedora/</a></p>
</li>
<li>
<p>Docker pode ser executado numa máquina real ou numa VM (não importa)</p>
<div class="ulist">
<ul>
<li>
<p>O fato: a arquitetura precisa ser 64 bits e executar um kernel Linux</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="baixando-e-executando-uma-vm-fedora-20-no-virtualbox"><a class="anchor" href="#baixando-e-executando-uma-vm-fedora-20-no-virtualbox"></a>Baixando e executando uma VM Fedora 20 no VirtualBox</h3>
<div class="ulist">
<ul>
<li>
<p>Instale o <a href="http://virtualbox.org">VirtualBox</a>;</p>
</li>
<li>
<p>Instale o <a href="http://7zip.org">7zip</a>;</p>
</li>
<li>
<p>Baixe e coloque minha <a href="http://gdriv.es/vm-fedora">minha vm-fedora</a> em funcionamento no teu VirtualBox:</p>
<div class="ulist">
<ul>
<li>
<p>Se desejar, <a href="https://github.com/paulojeronimo/vms/">leia como eu faço sua criação</a>;</p>
</li>
<li>
<p>Para fazer o seu download, extraí-la e executá-la, siga os seguintes passos:</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>cd ~/VirtualBox\ VMs/
bash &lt;(curl -L http://j.mp/vm-fedora-download)
7za x vm-fedora.7z.001
VBoxManage registervm "$PWD/vm-fedora/vm-fedora.vbox"
VBoxManage startvm vm-fedora</pre>
</div>
</div>
<div class="paragraph">
<p><em>Observação: poderíamos utilizar o <a href="https://www.vagrantup.com/">Vagrant</a> (leia <a href="http://paulojeronimo.github.io/tutorial-vagrant/">o tutorial que escrevi a seu respeito</a>) mas, neste tutorial, não estou utilizando-o.</em></p>
</div>
</div>
<div class="sect2">
<h3 id="configurando-a-vm-para-acesso-a-partir-de-uma-console-do-host"><a class="anchor" href="#configurando-a-vm-para-acesso-a-partir-de-uma-console-do-host"></a>Configurando a VM para acesso a partir de uma console do HOST</h3>
<div class="paragraph">
<p>A VM que baixamos só possui uma interface de rede (configura com o IP 10.0.2.5). A partir dela conseguimos navegar na Internet através de um NAT com a máquina HOST (nossa máquina, que está executando o VirtualBox). Tecnicamente, não há como fazer um ping ou mesmo acesar o IP da VM através da máquina HOST, nesse caso. Mas, há uma alternativa para isso que consiste na criação de um túnel reverso fazendo um ssh da console da VM para o HOST. Para testarmos essa alternativa, loguemos no console da VM (usuário <code>aluno</code>, senha <code>@lun0123</code>) e executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ssh -f -N -R 2222:localhost:22 pj@base</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Obviamente, você deverá substituir o meu usuário (<code>pj</code>) pelo o usuário que você tem em tua máquina. Detalhe: o host <code>base</code> tem o IP 10.0.2.2, que é o IP NAT de teu HOST</em>.</p>
</div>
<div class="paragraph">
<p>Dessa forma, a partir de um shell aberto no HOST, poderíamos acessar a VM com os seguintes comandos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ssh-copy-id -p 2222 aluno@localhost
ssh -p 2222 aluno@localhost</pre>
</div>
</div>
<div class="paragraph">
<p>O problema de fazer isso é que, mais a frente nesse tutorial, testaremos o acesso ao WildFly através de um IP válido para o HOST ao invés de fazermos túneis para as portas utilizadas pelo WildFly. Precisaremos parar a VM e fazer algumas configurações. Encerrando o ssh com a VM (<span class="keyseq"><kbd>Ctrl</kbd>+<kbd>D</kbd></span>) e voltando para o console do HOST, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">VBoxManage controlvm vm-fedora acpipowerbutton
VBoxManage hostonlyif create
VBoxManage hostonlyif ipconfig vboxnet0 --ip 192.168.0.253 --netmask 255.255.255.0
VBoxManage modifyvm vm-fedora --nic2 hostonly --hostonlyadapter2 vboxnet0
VBoxManage startvm vm-fedora
f=/etc/hosts; grep -v vm-fedora $f | sudo tee $f
echo -e "192.168.0.254\tvm-fedora" | sudo tee -a $f
cat $f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Façamos mais uma vez o logon na console da VM como usuário <code>aluno</code> (senha <code>@lun0123</code>). Executemos novamente o comando de criação do túnel reverso (<em>sugestão: utilize um <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>R</kbd></span> para encontrá-lo</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ssh -f -N -R 2222:localhost:22 pj@base</code></pre>
</div>
</div>
<div class="paragraph">
<p>Observemos também que, agora, há uma nova interface de rede nessa máquina (<code>p7p1</code>). Vejamos isso através da execução do comando a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ip a s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Precisamos configurar um IP estático para essa nova interface. Será esse IP que utilizaremos para fazer o acesso do HOST a VM. De volta ao console da máquina HOST, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ssh -p 2222 aluno@localhost</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora temos acesso remoto para a console da VM utilizando nosso HOST. Podemos simplesmente copiar e colar os comandos a seguir nessa console (<em>detalhe: copia/colar não seria possível de fazer, diretamente, do HOST para a VM pois o VirtualBox não oferece esta facilidade quando estamos trabalhando no modo texto, o que é o caso</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">cat &lt;&lt;'EOF' | sudo tee /etc/sysconfig/network-scripts/ifcfg-static-p7p1
DEVICE=p7p1
BOOTPROTO=none
ONBOOT=yes
IPADDR=192.168.0.254
PREFIX=24
GATEWAY=192.168.0.254
EOF
sudo nmcli con reload
sudo nmcli con up "System static-p7p1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Os comandos acima servem para configurar o IP estático 192.168.0.254 para a interface <code>p7p1</code>. Para verificar se tudo deu certo, façamos um ping para o outro IP do (HOST):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ping 192.168.0.253</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por fim, instalemos alguns utilitários que serão utilizados no decorrer desse tutorial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>sudo yum -y install vim tree lynx</pre>
</div>
</div>
<div class="paragraph">
<p>Voltemos ao console do HOST digitando um <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>D</kbd></span> e, em seguida, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ping vm-fedora
ssh-copy-id aluno@vm-fedora
ssh aluno@vm-fedora</code></pre>
</div>
</div>
<div class="paragraph">
<p>De agora em diante, executaremos todos os procedimentos que apresentarei no console da VM (a menos que eu dê alguma outra instrução).</p>
</div>
</div>
<div class="sect2">
<h3 id="instalando-o-docker"><a class="anchor" href="#instalando-o-docker"></a>Instalando o Docker</h3>
<div class="paragraph">
<p>Procedamos a instalação do Docker com os seguintes comandos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo yum -y install docker-io
sudo systemctl start docker
sudo systemctl enable docker</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="procurando-contêineres-no-docker-hub"><a class="anchor" href="#procurando-contêineres-no-docker-hub"></a>Procurando contêineres no Docker Hub</h3>
<div class="paragraph">
<p>Busquemos contêineres executando as seguintes instruções:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker search fedora | less
sudo docker search wildfly | less
sudo docker search rhq | less</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="baixando-e-executando-a-imagem-de-um-contêiner"><a class="anchor" href="#baixando-e-executando-a-imagem-de-um-contêiner"></a>Baixando e executando a imagem de um contêiner</h3>
<div class="paragraph">
<p>Agora, baixemos a imagem básica de um Fedora:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run -i -t fedora /bin/bash</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Parâmetros:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>run</code> - executa um contêiner</p>
</li>
<li>
<p><code>-i</code> - mantem o stdin aberto, mesmo que não haja nada anexado</p>
</li>
<li>
<p><code>-t</code> - aloca um pseudo terminal, dessa forma podermos interagir diretamente com o contêiner</p>
</li>
<li>
<p><code>fedora</code> - ID da imagem, pode ser uma tag ou um hash (id)</p>
</li>
<li>
<p><code>/bin/bash</code> - o comando que será executado após o contêiner ser iniciado</p>
</li>
</ol>
</div>
</li>
<li>
<p>Detalhes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se o contêiner não estiver no cache local ele será baixado</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Se quiséssesmos apenas baixar essa imagem, sem executar nada, poderíamos simplesmente rodar <code>sudo docker pull fedora</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>O prompt de comando apresentado será da forma root@&lt;id&gt;</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="gerenciamento-básico-do-contêiner"><a class="anchor" href="#gerenciamento-básico-do-contêiner"></a>Gerenciamento básico do contêiner</h3>
<div class="paragraph">
<p>Paremos o contêiner pressionando <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>D</kbd></span>. Ele será parado mas poderá ser reiniciado ou removido na hora que quisermos.</p>
</div>
<div class="paragraph">
<p>Para removermos o contêiner, precisaremos saber seu id e para isso, executaremos um <code>sudo docker ps</code>. A saída desse comando, entretanto, só nos mostra os ids dos contêineres em execução. Para listarmos os ids de todos os contêineres, até mesmo os que não estão em execução, executaremos esse mesmo comando informando o parâmetro <code>-a</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker ps -a</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nossa saída deverá ser similar a esta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
d30ae9376851        fedora:latest       "/bin/bash"         27 minutes ago      Exited (0) 24 minutes ago                       drunk_curie</code></pre>
</div>
</div>
<div class="paragraph">
<p>Removamos o contêiner, como no exemplo que eu apresento abaixo (substitua o id pelo que é apresentado na tua saída):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker rm d30ae9376851</code></pre>
</div>
</div>
<div class="paragraph">
<p>Executemos o contêiner novamente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run -i -t fedora /bin/bash</code></pre>
</div>
</div>
<div class="paragraph">
<p>Paremos o contêiner (<span class="keyseq"><kbd>Ctrl</kbd>+<kbd>D</kbd></span>) e listemos as images instaladas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker images</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vejamos, buscando e instalando, o espaço ocupado por uma image. Em seguida façamos sua remoção. Por exemplo, façamos a busca e a instalação de uma imagem do centos que tenha o tomcat instalado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker search centos | grep tomcat</code></pre>
</div>
</div>
<div class="paragraph">
<p>A listagem apresentada na saída do comando acima nos apresenta a imagem que podemos instalar com o comando a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker pull toprightgroup/narwhal-centos7-jdk7-tomcat8</code></pre>
</div>
</div>
<div class="paragraph">
<p>Depois de instalarmos a imagem, como eu disse, podemos ver seus detalhes executando o comando a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker images</code></pre>
</div>
</div>
<div class="paragraph">
<p>Observemos que a saída desse comando agora nos apresenta a seguinte listagem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>REPOSITORY                                   TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
fedora                                       latest              7d3f07f8de5f        About an hour ago   374.1 MB
toprightgroup/narwhal-centos7-jdk7-tomcat8   master              3c7716848106        5 weeks ago         621.5 MB
toprightgroup/narwhal-centos7-jdk7-tomcat8   b1                  7441456d75c2        7 weeks ago         618.2 MB</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notamos que a image <code>toprightgroup/narwhal-centos7-jdk7-tomcat8</code> (que não será utilizada) está ocupando mais de 1 GB no disco. Para removê-la, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker rmi 3c7
sudo docker rmi 744</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida podemos verificar se ela foi realmente removida executando o <code>sudo docker images</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="docker-em-projetos-jboss"><a class="anchor" href="#docker-em-projetos-jboss"></a>Docker em projetos JBoss</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O JBoss possui vários projetos utilizando o Docker. Leia mais sobre isso nos seguintes links:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.jboss.org/docker/" class="bare">http://www.jboss.org/docker/</a></p>
</li>
<li>
<p><a href="https://goldmann.pl/blog/2014/07/08/jboss-projects-as-docker-images/" class="bare">https://goldmann.pl/blog/2014/07/08/jboss-projects-as-docker-images/</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="wildfly-no-docker"><a class="anchor" href="#wildfly-no-docker"></a>WildFly no Docker</h3>
<div class="sect3">
<h4 id="executando-em-modo-standalone"><a class="anchor" href="#executando-em-modo-standalone"></a>Executando em modo standalone</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run -it jboss/wildfly</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dessa forma, para acessar o JBoss na porta 8080 (dentro da VM), é necessário descobrir o IP do contêiner. Abramos um novo console na VM e executemos os seguintes comandos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">CID=$(sudo docker ps -a | grep -i up | awk '{print $1}')
echo CID
IP=$(sudo docker inspect --format '{{ .NetworkSettings.IPAddress }}' $CID)
echo $IP</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora poderíamos abrir um browser dentro da VM (não temos interface gráfica) e acessar a URL <a href="http://$IP:8080" class="bare">http://$IP:8080</a>. Mas, esse é o nosso problema: esse IP só é acessível de dentro da VM! Mesmo assim, testemos utilizando um browser de linha de comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">lynx http://$IP:8080</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para acessarmos o WildFly a partir do HOST a solução é pedir que o docker crie mais dois túneis de acesso (para as portas 8080 e 9990) entre a VM e o contêiner. Para fazer isso, damos um <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>C</kbd></span> na execução corrente do WildFly e, em seguida, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run -it -p 8080:8080 -p 9990:9990 jboss/wildfly</code></pre>
</div>
</div>
<div class="paragraph">
<p>Podemos agora acessar, no HOST, a URL <a href="http://vm-fedora:8080" class="bare">http://vm-fedora:8080</a>. Para acessar a interface administrativa, ainda precisamos da adição de um usuário administrativo. Modificaremos nosso contêiner adionando esse usuário. Paremos novamente o contêiner em execução (<span class="keyseq"><kbd>Ctrl</kbd>+<kbd>C</kbd></span>) e executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">mkdir -p ~/wildfly-management
cd !$
cat &gt; Dockerfile &lt;&lt;EOF
FROM jboss/wildfly
RUN /opt/wildfly/bin/add-user.sh admin Admin#70365 --silent
EOF
sudo docker build -t wildfly-management .</code></pre>
</div>
</div>
<div class="paragraph">
<p>O que fizemos agora foi criar uma image própria, derivada da image <code>jboss/wildfly</code>, e apenas adicionamos as configurações necessárias para a inclusão de um usuário de administração do JBoss.</p>
</div>
<div class="paragraph">
<p>Executemos o comando <code>sudo docker images</code>. Com isso, obteremos a seguinte saída:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>REPOSITORY           TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
wildfly-management   latest              31961a1179fa        20 seconds ago      929 MB
fedora               latest              7d3f07f8de5f        About an hour ago   374.1 MB
jboss/wildfly        latest              bf5508a3f1c7        12 hours ago        929 MB</code></pre>
</div>
</div>
<div class="paragraph">
<p>Executemos o WildFly, novamente, de forma que possamos acessar sua interface administrativa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker run -it --rm -p 8080:8080 -p 9990:9990 wildfly-management</code></pre>
</div>
</div>
<div class="paragraph">
<p>Recarregando a URL <a href="http://vm-fedora:8080" class="bare">http://vm-fedora:8080</a>, agora teremos acesso a interface administrativa após informar o usuário <code>admin</code> e a senha <code>Admin#70365</code>.</p>
</div>
<div class="paragraph">
<p>O Docker nos oferece uma forma de visualizar as diferenças entre a image (read-only) e o contêiner. Para isso, precisamos executar um <code>docker ps -a</code> (façamos isso em outra console da VM, enquanto o WildFly está executando). Sua saída será similar a esta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CONTAINER ID        IMAGE                       COMMAND                CREATED             STATUS                           PORTS                                            NAMES
23661d0835ee        wildfly-management:latest   "/opt/wildfly/bin/st   45 minutes ago      Up 45 minutes                    0.0.0.0:8080-&gt;8080/tcp, 0.0.0.0:9990-&gt;9990/tcp   naughty_archimedes
aa4272a565ca        jboss/wildfly:latest        "/opt/wildfly/bin/st   About an hour ago   Exited (130) 55 minutes ago                                                       dreamy_nobel
746e8e569540        jboss/wildfly:latest        "/opt/wildfly/bin/st   About an hour ago   Exited (130) About an hour ago                                                    tender_tesla
75653974d524        fedora:latest               "/bin/bash"            About an hour ago   Exited (0) About an hour ago                                                      agitated_goodall</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notemos a coluna <code>NAMES</code> nessa saída e utilizemos o seu valor para para o contêiner 236, na execução do comando a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sudo docker diff naughty_archimedes</code></pre>
</div>
</div>
<div class="paragraph">
<p>A saída desse comando, apresentada abaixo, lista as mudanças no sistema de arquivos, em relação a image:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>C /opt/wildfly-8.1.0.Final/standalone
C /opt/wildfly-8.1.0.Final/standalone/configuration
C /opt/wildfly-8.1.0.Final/standalone/configuration/logging.properties
A /opt/wildfly-8.1.0.Final/standalone/configuration/standalone_xml_history
A /opt/wildfly-8.1.0.Final/standalone/configuration/standalone_xml_history/current
A /opt/wildfly-8.1.0.Final/standalone/configuration/standalone_xml_history/snapshot
A /opt/wildfly-8.1.0.Final/standalone/configuration/standalone_xml_history/standalone.boot.xml
A /opt/wildfly-8.1.0.Final/standalone/configuration/standalone_xml_history/standalone.initial.xml
A /opt/wildfly-8.1.0.Final/standalone/configuration/standalone_xml_history/standalone.last.xml
A /opt/wildfly-8.1.0.Final/standalone/data
A /opt/wildfly-8.1.0.Final/standalone/data/content
A /opt/wildfly-8.1.0.Final/standalone/data/timer-service-data
A /opt/wildfly-8.1.0.Final/standalone/data/tx-object-store
A /opt/wildfly-8.1.0.Final/standalone/data/tx-object-store/ShadowNoFileLockStore
A /opt/wildfly-8.1.0.Final/standalone/data/tx-object-store/ShadowNoFileLockStore/defaultStore
A /opt/wildfly-8.1.0.Final/standalone/log
A /opt/wildfly-8.1.0.Final/standalone/log/server.log
C /opt/wildfly-8.1.0.Final/standalone/tmp
A /opt/wildfly-8.1.0.Final/standalone/tmp/vfs
A /opt/wildfly-8.1.0.Final/standalone/tmp/vfs/temp
C /tmp/hsperfdata_wildfly
A /tmp/hsperfdata_wildfly/53</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="executando-em-modo-domain"><a class="anchor" href="#executando-em-modo-domain"></a>Executando em modo domain</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="explorando-mais"><a class="anchor" href="#explorando-mais"></a>Explorando mais</h4>
<div class="paragraph">
<p>Dá para explorar várias coisas a mais &#8230;&#8203; Para isso, veja estas referências:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apresentação do Marek Goldmann no <a href="https://www.youtube.com/channel/UCrAKwbOeiDKtTShxLCKFvNg">Virtual JBoss User Group</a> (Setembro/2014):</p>
<div class="ulist">
<ul>
<li>
<p>Vídeo: <a href="https://www.youtube.com/watch?v=4uQ6gR_xZhE" class="bare">https://www.youtube.com/watch?v=4uQ6gR_xZhE</a></p>
</li>
<li>
<p>Exemplos: <a href="https://github.com/goldmann/goldmann.pl/tree/master/.presentations/2014-vjbug-docker/demos" class="bare">https://github.com/goldmann/goldmann.pl/tree/master/.presentations/2014-vjbug-docker/demos</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://goldmann.pl/blog/2014/03/06/creating-a-minimal-wildfly-docker-image/" class="bare">https://goldmann.pl/blog/2014/03/06/creating-a-minimal-wildfly-docker-image/</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rhq-executando-no-docker"><a class="anchor" href="#rhq-executando-no-docker"></a>RHQ executando no Docker</h3>
<div class="paragraph">
<p>O <a href="http://rhq.jboss.org/">RHQ</a> é um produto de monitoração que é a base para o <a href="http://www.redhat.com/en/technologies/jboss-middleware/operations-network">JON</a>. Para instalá-lo via Docker, executemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">git clone https://github.com/rhq-project/docker.git rhq-docker
cd !$/dockerfile
sudo ./build.sh
sudo ./run.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Explore mais detalhes nos seguintes links:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/rhq-project/docker" class="bare">https://github.com/rhq-project/docker</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=hx43fQh-RVQ&amp;feature=youtu.be" class="bare">https://www.youtube.com/watch?v=hx43fQh-RVQ&amp;feature=youtu.be</a></p>
</li>
</ul>
</div>
</div>
</div>
</div></div><div class="footer"><div class="container"><p>Published site: <a href="http://paulojeronimo.github.io/JUDCon-2014-Brazil">http://paulojeronimo.github.io/JUDCon-2014-Brazil</a><br>Source code: <a href="http://github.com/paulojeronimo/JUDCon-2014-Brazil">http://github.com/paulojeronimo/JUDCon-2014-Brazil</a></p></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script><script src="http://paulojeronimo.github.io/JUDCon-2014-Brazil/js/bootstrap.min.js"></script></body></html>